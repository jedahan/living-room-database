!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e(require("events")):"function"==typeof define&&define.amd?define(["events"],e):t.RoomDB=e(t.EventEmitter)}(this,function(t){"use strict";t=t&&t.hasOwnProperty("default")?t.default:t;const e=require("ohm-js").grammar('\n  G {\n\n    factOrPattern\n      = term*\n\n    term\n      = id\n      | word\n      | value\n      | variable\n      | wildcard\n      | hole\n\n    id\n      = "#" alnum*\n\n    value\n      = keyword<"true">   -- true\n      | keyword<"false">  -- false\n      | keyword<"null">   -- null\n      | number\n      | string\n\n    variable\n      = "$" alnum+\n\n    wildcard\n      = "$"\n\n    hole\n      = "_"\n\n    word\n      = (~special any)+  -- nonspace\n      | space+           -- space\n\n    keyword<k>\n      = k ~alnum\n\n    number\n      = float ("e" float)?\n\n    float\n      = integer ("." digit+)?\n\n    integer\n      = ("+" | "-")? digit+\n\n    string\n      = "\\"" (~"\\"" ~"\\n" any)* "\\""\n\n    special\n      = id | value | variable | wildcard | hole | space\n\n  }\n'),r=e.createSemantics().addOperation("parse",{factOrPattern:t=>t.parse(),id:(t,e)=>({id:e.sourceString}),value_true:t=>({value:!0}),value_false:t=>({value:!1}),value_null:t=>({value:null}),variable:(t,e)=>({variable:e.sourceString}),wildcard:t=>({wildcard:!0}),hole:t=>({hole:!0}),word_nonspace(t){return{word:this.sourceString}},word_space:t=>({word:" "}),number(t,e,r){return{value:parseFloat(this.sourceString)}},string(t,e,r){const s=[];let n=0;for(e=e.parse();n<e.length;){let t=e[n++];if("\\"===t&&n<e.length)switch(t=e[n++]){case"n":t="\n";break;case"t":t="\t";break;default:n--}s.push(t)}return{value:s.join("")}},_terminal(){return this.sourceString}});const s=1e3;class n{constructor(t){this._id=t,this._parseCache=new Map,this._asserts=[],this._retracts=[]}assert(t,...e){const r=this._toJSONFactOrPattern(t,...e);this._asserts.push(r)}retract(t,...e){const r=this._toJSONFactOrPattern(t,...e);this._retracts.push(r)}async flushChanges(){throw new Error("subclass responsibility")}async immediatelyAssert(t,...e){this.assert(t,...e),await this.flushChanges()}async immediatelyRetract(t,...e){this.retract(t,...e),await this.flushChanges()}async immediatelyRetractEverythingAbout(t){throw new Error("subclass responsibility")}async immediatelyRetractEverythingAssertedByMe(){throw new Error("subclass responsibility")}async getAllFacts(){throw new Error("subclass responsibility")}_toJSONFactOrPattern(t,...e){if(0===arguments.length)throw new Error("not enough arguments!");if("string"!=typeof t)throw new Error("factOrPatternString must be a string!");let r=this._parse(t);e.length>0&&(r=r.slice());for(let t=0;t<r.length;t++){if(r[t].hasOwnProperty("hole")){if(0===e.length)throw new Error("not enough filler values!");r[t]=this._toJSONTerm(e.shift())}}if(e.length>0)throw new Error("too many filler values!");return r}_toJSONTerm(t){return{value:t}}_parse(t){if(this._parseCache.has(t))return this._parseCache.get(t);{this._clearParseCacheIfTooBig();const s=function(t,s){const n=s||"factOrPattern",a=e.match(t.trim(),n);if(a.succeeded())return r(a).parse();throw new Error(`invalid ${n}: ${t}`)}(t);return this._parseCache.set(t,s),s}}_clearParseCacheIfTooBig(){this._parseCache.size>s&&this.clearParseCache()}clearParseCache(){this._parseCache.clear()}}class a{toString(){throw new Error("subclass responsibility")}toJSON(){throw new Error("subclass responsibility")}toRawValue(){throw new Error("subclass responsibility")}match(t,e){throw new Error("subclass responsibility")}}a.fromJSON=(t=>{if(t.hasOwnProperty("id"))return new i(t.id);if(t.hasOwnProperty("word"))return new o(t.word);if(t.hasOwnProperty("value"))return new c(t.value);if(t.hasOwnProperty("blobRef"))return new l(t.blobRef);if(t.hasOwnProperty("variable"))return new h(t.variable);if(t.hasOwnProperty("wildcard"))return new u;if(t.hasOwnProperty("hole"))return new class extends a{constructor(){super()}toString(){return"_"}toJSON(){return{hole:!0}}toRawValue(){throw new Error("Hole's toRawValue() should never be called!")}match(t,e){throw new Error("Hole's match() should never be called!")}};throw new Error("unrecognized JSON term: "+JSON.stringify(t))});class i extends a{constructor(t){super(),this.name=t}toString(){return"#"+this.name}toJSON(){return{id:this.name}}toRawValue(){return this}match(t,e){return t instanceof i&&this.name===t.name?e:null}}class o extends a{constructor(t){super(),this.value=t}toString(){return this.value}toJSON(){return{word:this.value}}toRawValue(){return this}match(t,e){return t instanceof o&&this.value===t.value?e:null}}class c extends a{constructor(t){super(),this.value=t}toString(){return JSON.stringify(this.value)}toJSON(){return{value:this.value}}toRawValue(){return this.value}match(t,e){return t instanceof c&&this.value===t.value?e:null}}class l extends a{constructor(t){super(),this.id=t}toString(){return"@"+this.id}toJSON(){return{blobRef:this.id}}toRawValue(){return this}match(t,e){return t instanceof l&&this.id===t.id?e:null}}class h extends a{constructor(t){super(),this.name=t}toString(){return"$"+this.name}toJSON(){return{variable:this.name}}toRawValue(){throw new Error("Variable's toRawValue() should never be called!")}match(t,e){return void 0===e[this.name]?(e[this.name]=t,e):e[this.name].match(t,e)}}class u extends a{constructor(){super()}toString(){return"$"}toJSON(){return{wildcard:!0}}toRawValue(){throw new Error("Wildcard's toRawValue() should never be called!")}match(t,e){return e}}class d extends n{constructor(t,e){super(e),this._db=t}subscribe(t,e){"string"==typeof t&&(t=[t]);const r=t.map(t=>this._toJSONFactOrPattern(t));return this._db.on(JSON.stringify(r),e)}select(...t){const e=t.map(t=>t instanceof Array?this._toJSONFactOrPattern(...t):this._toJSONFactOrPattern(t)),r=this._db.select(...e),s={doAll:async t=>(await t(r),s),async do(t){for(let e of r){for(let t in e){const r=JSON.parse(JSON.stringify(e[t]));e[t]=a.fromJSON(r).toRawValue()}await t(e)}return s},count:async()=>r.length,isEmpty:async()=>0===r.length,isNotEmpty:async()=>r.length>0};return s}async flushChanges(){this._retracts.forEach(t=>this._db.retract(this._id,t)),this._retracts=[],this._asserts.forEach(t=>this._db.assert(this._id,t)),this._asserts=[]}async immediatelyRetractEverythingAbout(t){return this._db.retractEverythingAbout(this._id,t)}async immediatelyRetractEverythingAssertedByMe(){return this._db.retractEverythingAssertedBy(this._id)}async getAllFacts(){return this._db.getAllFacts()}toString(){return`[LocalClient ${this._id}]`}}module.exports=d;class f{constructor(t){this.terms=t}hasVariablesOrWildcards(){return this.terms.some(t=>t instanceof h||t instanceof u)}match(t,e){if(this.terms.length!==t.terms.length)return null;for(let r=0;r<this.terms.length;r++){const s=this.terms[r],n=t.terms[r];if(!s.match(n,e))return null}return e}toString(){return this.terms.map(t=>t.toString()).join("")}}function w(t){for(let e in t)t[e]=t[e];return t}function m(t,e){let r=t;for(let t of e)r.delete(t);return r}f.fromJSON=(t=>new f(t.map(t=>a.fromJSON(t))));return class extends t{constructor(){super(),this._factMap=new Map,this._subscriptions=new Set,this.on("newListener",(t,e)=>{this._subscriptions.add(t),console.log(`now there are ${this._subscriptions.size} subscriptions!`)})}select(...t){const e=t.map(t=>f.fromJSON(t)),r=[];return this._collectSolutions(e,Object.create(null),r),r.map(w)}_collectSolutions(t,e,r){if(0===t.length)r.push(e);else{const s=t[0];for(let n of this._facts){const a=Object.create(e);s.match(n,a)&&this._collectSolutions(t.slice(1),a,r)}}}_emitChanges(t){const e=this._subscriptions,r=new Map;e.forEach(t=>{const e=JSON.parse(t),s=this.select(...e);r.set(t,new Set(s.map(JSON.stringify)))}),t();const s=new Map;e.forEach(t=>{const e=JSON.parse(t),r=this.select(...e);s.set(t,new Set(r.map(JSON.stringify)))}),e.forEach(t=>{const e=r.get(t),n=s.get(t),a=Array.from(m(n,e)).map(JSON.parse),i=Array.from(m(e,n)).map(JSON.parse);a.length+i.length&&this.emit(t,{pattern:t,assertions:a,retractions:i})})}assert(...t){const e=this._assert.bind(this,...t);this._emitChanges(e)}_assert(t,e){if(void 0===e)throw new Error("factJSON is undefined");const r=f.fromJSON(e);if(r.hasVariablesOrWildcards())throw new Error("cannot assert a fact that has variables or wildcards!");r.asserter=t,this._factMap.set(r.toString(),r)}retract(...t){const e=this._retract.bind(this,...t);this._emitChanges(e)}_retract(t,e){const r=f.fromJSON(e);if(r.hasVariablesOrWildcards()){const t=this._facts.filter(t=>r.match(t,Object.create(null)));return t.forEach(t=>this._factMap.delete(t.toString())),t.length}return this._factMap.delete(r.toString())?1:0}retractEverythingAbout(t,e){const r=new i(e),s=Object.create(null),n=this._facts.filter(t=>t.terms.some(t=>r.match(t,s)));return n.forEach(t=>this._factMap.delete(t.toString())),n.length}retractEverythingAssertedBy(t){const e=this._facts.filter(e=>e.asserter===t);return e.forEach(t=>this._factMap.delete(t.toString())),e.length}get _facts(){return Array.from(this._factMap.values())}getAllFacts(){return this._facts.map(t=>t.toString())}toString(){return this._facts.map(t=>"<"+t.asserter+"> "+t.toString()).join("\n")}client(t="local-client"){return new d(this,t)}}});
//# sourceMappingURL=RoomDB.min.js.map
